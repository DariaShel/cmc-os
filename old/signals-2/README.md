# Сигналы, часть 2.

## Небезопасные функции в обработчиках сигналов

В обработчиках сигналов не рекомендуется использовать функции, не входящие в список
асинхронно-безопасных функций (async-signal safe).
Сам список можно найти в соответствующем разделе страницы руководства `signal(7)`,
которое можно получить по команде
```
man 7 signal
```

В частности, в список асинхронно-безопасных не входят функции ввода-вывода
из `<stdio.h>` и функции выделения-освобождения динамической памяти из `<stdlib.h>`.

Опасность использования `printf` и в основной программе, и в обработчике сигнала
демонстрируется следующим примером:

```
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>

void handler(int s)
{
    static int count = 0;
    printf("In handler: %d\n", ++count);
}

int main(void)
{
    signal(SIGUSR1, handler);
    int pid = fork();
    if (!pid) {
        while (1) {
            int count = 0;
            printf("In program: %d\n", ++count);
        }
    } else {
        // parent
        while (1) {
            kill(pid, SIGUSR1);
            sched_yield();
        }
    }
}
```

В нем процесс-сын постоянно выводит строку на стандартный поток вывода, но по получению
сигнала `SIGUSR1` строка выводится из обработчика сигнала. Процесс-родитель постоянно
шлет сигнал `SIGUSR1` сыну, но вызывает `sched_yield`, чтобы дать возможность ему
выполняться.

В выводе этой программы могут встретиться подобные строки:
```
In program: In handler: 15
119872
In program: 119873
```
то есть целостность вывода была нарушена.

## Установка флагов в обработчиках сигнала

Обычно обработчики сигналов не выполняют никаких действий, кроме установки переменной-флага.
Напишем простую программу, которая получает и обрабатывает сигнал `SIGINT` и выводит
сообщение об этом.

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

int caught = 0;

void handler(int s)
{
    caught = 1;
}

int main(void)
{
    signal(SIGINT, handler);
    while (1) {
        while (!caught) {
            // здесь активное ожидание и это важно
        }
        printf("caught\n");
        caught = 0;
    }
}
```

Если скомпилировать эту программу без оптимизаций командой
```
gcc -Wall -Werror -std=gnu11 program.c -o program
```

запустим, и после запуска нажмем Ctrl-C, получим ожидаемый результат
```
[cher@localhost signals]$ ./program
^Ccaught
```

Но если скомпилируем программу со включенными оптимизациями
```
gcc -O2 -Wall -Werror -std=gnu11 program.c -o program
```

результат может оказаться неожиданным:
```
[cher@localhost signals]$ ./program
^C
```

Программа ничего не напечатала!

Если мы посмотрим на ассемблерный код, сгенерированный компилятором
```
gcc -O2 -Wall -Werror -std=gnu11 program.c -S -o program.s
```

то увидим там примерно следующий фрагмент
```
    movl    caught, %eax
    testl   %eax, %eax
    jne .L7
.L6:
    jmp .L6
.L7:
```

компилятор вынес проверку переменной `caught` из цикла, превратив цикл в вечный.
Компилятор Си имеет право предполагать, что операторы программы выполняются строго
в том порядке, в котором они присутствуют в тексте программы. Видя, что переменная
`caught` не модифицируется в цикле ожидания, компилятор оптимизирует цикл.

Чтобы запретить такие оптимизации переменную `caught` нужно объявлять с ключевым словом
`volatile`.
```
volatile int caught;
```

Ключевое слово `volatile` говорит компилятору о том, что значение переменной может измениться
в любой момент "неожиданно" для компилятора. Поэтому компилятор не должен пытаться
оптимизировать обращения к этой переменной: сохранять ее на регистрах, выносить проверки из цикла и т. п.

Поэтому глобальные переменные, модифицируемые из обработчиков сигналов, должны быть
объявлены с модификатором `volatile`.

Еще при использовании переменных-флагов необходимо удостовериться, что модификация переменной
и проверка ее значения каждые требует не более одной процессорной инструкции. Например,
если использовать тип `long long` в качестве переменной, хранящей флаг, на 32-битной платформе
(странное решение само по себе), сохранение значения в такую переменную, как и провека ее значения
потребуют более одной инструкции, как показано ниже

```
.L3:
    movl    caught, %eax
    movl    caught+4, %edx
    movl    %edx, %ecx
    orl %eax, %ecx
    je  .L3
```

Тогда возможен race condition, когда обработчик сигнала частично проверил модифицировал, а основная программа
уже проверила флаг. Переменная-флаг должна быть *атомарна*. Для атомарных переменных вполне безопасно
использовать тип `int` (утверждается, что в настоящее время нет POSIX-систем, на которых это не так),
но чтобы гарантировать атомарность на любой вообразимой платформе, можно использовать тип `sig_atomic_t`.

Итак, правильное определение переменной-флага, которая предназначена для установки признака получения
сигнала, выглядит следующим образом:
```
volatile sig_atomic_t caught;
```

## Ожидание прихода сигнала

В предыдущей программе использовался пустой цикл для ожидания прихода сигнала:
```
        while (!caught) {
            // здесь активное ожидание
        }
```

Циклы активного ожидания практически никогда не допустимы в программе. Активное ожидание
не выполняет никаких полезных действий в самой программе, но потребляет процессорное время,
мешая выполняться другим программам. Правильнее всего, чтобы программа, ожидающая
прихода сигнала, выполнила системный вызов, предназначенный для ожидания сигнала.

```
        while (!caught) {
            pause();
        }
```

Но тем самым в программу внесена ошибка race condition. Если посмотреть на сгенерированный
код:

```
.L3:
    movl    caught, %eax
    testl   %eax, %eax
    jne .L8
    call    pause
    jmp .L3
```

между чтением переменной `caught` из памяти и вызовом системного вызова `pause`
выполняется несколько машинных инструкций.

Можно попытаться решить проблему, приостанавливая работу программы не
на неопределенное время, а на небольшое, чтобы, если момент получения
сигнала был пропущен, мы бы все равно вернулись к проверке
значения переменной через некоторое время. Например, так

```
        while (!caught) {
            sched_yield();
        }
```

Этот вариант немного лучше активного ожидания, так как если сигнал
не пришел, процесс передает право выполнения другим процессам в системе,
но все равно, процесс считается готовым к выполнению, и ядро
операционной системы будет ставить его на выполнение каждый раз,
когда до него дойдет очередь. Что вполне может превратиться
в постоянную загрузку процессорного ядра. Правильные варианты
решения этой задачи мы рассмотрим ниже.

## Потери при доставке сигналов

Рассмотрим следующую программу:

```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

int send_cnt = 0;
int recv_cnt = 0;

void hand1(int s)
{
    ++recv_cnt;
}

void hand2(int s)
{
    printf("%d %d\n", send_cnt, recv_cnt);
    exit(0);
}

int main(void)
{
    signal(SIGUSR1, hand1);
    signal(SIGINT, hand2);
    if (!fork()) {
        while (1) {
            kill(getppid(), SIGUSR1);
            ++send_cnt;
        }
    } else {
        while (1) {
            pause();
        }
    }
}
```

В этой программе процесс-сын постоянно отправляет сигнал `SIGUSR1` отцу, подсчитывая число
отправленных сигналов. Процесс-отец получает сигнал `SIGUSR1`, подсчитывая число принятых
сигналов. По нажатию на терминале Ctrl-C оба процесса получают сигнал `SIGINT`,
выводят свои значения счетчиков и завершают работу. Запустив программу на несколько
секунд, а затем нажав Ctrl-C мы получим примерно следующий вывод:

```
[cher@localhost signals]$ ./siga 
^C0 1539003
[cher@localhost signals]$ 4894810 0
```

Как видно, расхождение между числом отправленных и числом полученных сигналов
составляет более трех раз. Чтобы объяснить такое поведение системы, необходимо рассмотреть
механизм отправки и доставки сигналов.

## Механизм отправки сигналов

В файле /proc/PID/status (PID нужно заменить на численный идентификатор процесса) за
настройки и состояние процесса для обработки сигналов отвечают следующие строки

```
SigPnd:	0000000000000000
SigBlk:	0000000000000000
SigIgn:	0000000000000000
SigCgt:	0000000000000000
```

попробуем разобраться, что они означают. Системный вызов `signal` позволяет
установить обработчик сигнала в одно из следующих значений: обрабатываемый
по умолчанию (`SIG_DFL`), игнорируемый (`SIG_IGN`) или пользовательский.
Если мы установим обработку сигнала в игнорирование
```
    signal(SIGINT, SIG_IGN);
    signal(SIGUSR1, SIG_IGN);
```

то изменится одна строка в статусе процесса:

```
SigIgn:	0000000000000202
```

Такое значение будет получена на Linux/i386. На другой архитектуре
значением может быть другим. Номер сигнала `SIGINT` - 2, номер
сигнала `SIGUSR1` - 10. Каждый сигнал представлен одним битом
(сигнал номер 1 - `SIGHUP` - это младший бит). Значение `SigIgn` -
это **множество игнорируемых сигналов** - 64-битное число,
напечатанное в шестнадцатеричном виде. В нем каждому типу сигнала
соответствует один бит.

По аналогии, параметры `SigPnd`, `SigBlk`, `SigCgt` - это множества сигналов,
хранящиеся в 64-битном чисел и отображающиеся в шестнадцатеричном виде.

Множество сигналов `SigPnd` - это множество сигналов, ожидающих доставки
(pending delivery). В это множество добавляются сигналы, которые уже
были отправлены некоторому процессу, но еще не были им обработаны.
Каждому типу сигнала соответствует один бит, поэтому, если
послать процессу дважды один и тот же сигнал так, что процесс не успеет его
обработать, то бит в множестве сигналов, ожидающих доставки, будет установлен
только один раз, во второй раз он не изменится. Поэтому с точки зрения
процесса-получателя до него дойдет только один сигнал из двух.

Итак, отправка сигнала происходит по слеующему алгоритму.
```
    kill(pid, sig);
```

* в списке процессов находим процесс с идентификатором `pid`.
Если такой процесс не существует, системный вызов завершается с ошибкой `ESRCH`.
* проверяем, имеет ли право процесс-отправитель послать сигнал процессу-получателю.
Если нет, системный вызов завершается с ошибкой `EPERM`.
* если номер сигнала `sig` равен 0, то никакой сигнал при этом не посылается,
работа системного вызова завершается успешно.
* проверяем наличие сигнала `sig` во множестве игнорируемых сигналов.
Если находим, то работа системного вызова завершается успешно.
* добавляем сигнал `sig` во множество сигналов ожидающих доставки.
* системный вызов завершается успешно.

В конце выполнения системного вызова `kill` может происходить запуск планировщика
процессов ядра операционной системы и может быть поставлен на выполнение процесс-получатель.
Но может продолжить выполнение и процесс отправитель. Порядок выполнения процессов, как обычно,
недетерминирован.

Сигналы `SIGKILL` и `SIGSTOP` не могут быть игнорированы. Поэтому соответствующие биты
в множестве игнорируемых сигналов для них всегда равны 0.

## Механизм получения сигналов

Таким образом в процессе накапливается множество сигналов, ожидающих доставки.
Если в момент отправки сигнала в процесс он находился в состоянии ожидания ('S'), он будет разбужен и поставлен
в очередь готовых к выполнению.

Когда планировщик будет ставить процесс на выполнение на некоторый процессор, прежде чем передать
управление в код процесса будет проверено множество сигналов, ожидающих доставки.
В этот момент вступает в игру множество *заблокированных сигналов* (SigBlk). Оно содержит сигналы,
обработка которых должна быть отложена на неопределенное время, пока сам процесс не пожелает
их обработать. Если некоторый сигнал находится во множестве сигналов, ожидающих доставки,
и он же находится во множестве заблокированных сигналов, он не будет обработан немедленно,
а просто останется во множестве сигналов, ожидающих доставки.

Выполнив операцию SigPnd & ~SigBlk мы получим множество сигналов, готовых к доставке.
Ядро просматривает выбирает из этого множества какой-то сигнал. Затем либо выполняется обработка
по умолчанию для этого сигнала, либо управление передается в пользовательский обработчик сигнала.
Естественно, этот сигнал удаляется из множества сигналов, ожидающих доставки.

Если процесс пережил обработку сигнала (не завершился), то при выходе из пользовательского
обработчика сигнала управление снова попадет в ядро, и ядро снова проверит сигналы,
готовые к доставке, и, возможно, снова запустит еще какой-нибудь обработчик. То есть, при выходе из обработчика
сигнала управление может даже не вернуться к основной программе, а снова попасть в обработчик сигнала,
возможно в тот же самый, который только что завершился.

Стандартно в современных Unix-системах на время работы обработчика сигнала сам этот сигнал блокируется.
То есть перед вызовом пользовательского обработчика в множестве заблокированных сигналов
устанавливается соответствующий бит, а после возврата из обработчика он снимается. И если обработчик некоторого
сигнала пошлет этот самый сигнал себе, то сигнал будет добавлен в множество сигналов, ожидающих доставки,
и будет там находиться до завершения обработчика, так как сигнал заблокирован. Но как только обработчик завершился,
сигнал разблокируется, и только что завершившийся обработчик перезапустится сначала.

## Блокировка сигналов

Программист может манипулировать множеством заблокированных сигналов. Для хранения множеств сигналов
определен тип `sigset_t`. Работать с ним можно с помощью специальных функций, описанных ниже.

```
int sigemptyset(sigset_t *set);
```

Функция очищает множество сигналов. После её выполнения множество не содержит ни одного сигнала. Функцию необходимо использовать,
так как начальное значение локальных переменных неопределено.

```
int sigfillset(sigset_t *set);
```

Эта функция, наоборот, заполняет множество сигналов. После её выполнения множество содержит все сигналы. Функцию можно
использовать как альтернативу `sigemptyset` для начальной инициализации множества.

```
int sigaddset(sigset_t *set, int signum);
```

Функция добавляет сигнал `signum` в множество `set`.

```
int sigdelset(sigset_t *set, int signum);
```

Функция удаляет сигнал `signum` из множества `set`.

```
int sigismember(const sigset_t *set, int signum);
```

Функция проверяет наличие сигнала `signum` в множестве `set`. Если сигнал принадлежит
множеству, возвращается истинное значение, а если не принадлежит - ложное.

Все эти функции манипулируют с множеством сигналов локально в процессе. Они не изменяют множество
заблокированных сигналов непосредственно.

Чтобы модифицировать множество заблокированных сигналов используется функция
```
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

Вне зависимости от параметра `how`, если параметр `oldset` не равен `NULL`, в него будет
записано множество заблокированных сигналов на момент данного вызова `sigprocmask`. Если
старое значение не нужно, в качестве `oldset` передается `NULL`.

Параметр `how` задает операцию, применяемую ко множеству заблокированных сигналов.
Константа `SIG_BLOCK` указывает, что множество `set` нужно добавить
ко множеству заблокированных сигналов, то есть `SigBlk |= set`.
Константа `SIG_UNBLOCK` указывает, что множество `set` нужно удалить
из множества заблокированных сигнанов, то есть `SigBlk &= ~set`.
Константа `SIG_SETMASK` копирует множество `set`, то есть `SigBlk = set`.

В любом случае, не получится добавить в множество заблокированных сигналов `SIGKILL` и `SIGSTOP`.
Они будут принудительно очищены из множества ядром.

Вернемся к примеру с ожиданием сигнала `SIGINT`. Для того, чтобы избежать множества проблем,
связанных с асинхронностью поступления сигналов в программу, программа должна работать с заблокированными
сигналами. Лишь тогда, когда программа готова реагировать на поступление сигналов,
они должны разблокироваться.

Для этого заблокируем `SIGINT` в начале программы, и разблокируем его в точке ожидания поступления сигнала.


```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

volatile sig_atomic_t caught = 0;

void handler(int s)
{
    caught = 1;
}

int main(void)
{
    signal(SIGINT, handler);
    sigset_t s, os;
    sigemptyset(&s);
    sigaddset(&s, SIGINT);
    sigprocmask(SIG_BLOCK, &s, &os); // в переменной os сохранится старое значение маски сигналов
    while (1) {
        while (!caught) {
            sigprocmask(SIG_SETMASK, &os, NULL);
            pause();
            sigprocmask(SIG_BLOCK, &s, NULL);
        }
        printf("caught\n");
        caught = 0;
    }
}
```

Однако последовательность `sigprocmask`, `pause`, `sigprocmask` обладает все тем же недостатком: она не атомарна.
Если `SIGINT` поступил при заблокированных сигналах, еще до возврата из первого `sigprocmask` он будет обработан,
что приведет к его пропуску и входу в ожидание в `pause`. Поэтому правильно последовательность `sigprocmask`, `pause`,
`sigprocmask` заменить на один системный вызов `sigsuspend`.

```
int sigsuspend(const sigset_t *mask);
```

Этот системный вызов приостанавливает выполнение процесса до поступления в него неблокируемого сигнала,
причем на время ожидания множество блокируемых сигналов устанавливается в `mask`. Поскольку операция
модификации множества блокируемых сигналов выполняется в одном системном вызове с ожиданием сигнала,
race condition между модификацией множеств и поступлением сигналов.

Итоговая программа выглядит так:

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

volatile sig_atomic_t caught = 0;

void handler(int s)
{
    caught = 1;
}

int main(void)
{
    signal(SIGINT, handler);
    sigset_t s, os;
    sigemptyset(&s);
    sigaddset(&s, SIGINT);
    sigprocmask(SIG_BLOCK, &s, &os); // в переменной os сохранится старое значение маски сигналов
    while (1) {
        while (!caught) {
            sigsuspend(&os); // на время ожидания сигналов восстанавливаем оригинальное множество заблокированных сигналов
        }
        printf("caught\n");
        caught = 0;
    }
}
```

## Блокировка/игнорирование сигналов-исключений

Сигналы, посылаемые в процесс при возникновении исключительной ситуации можно заблокировать или игнорировать.
Например,

```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int main(void)
{
    sigset_t s1, s2;
    sigemptyset(&s1);
    sigaddset(&s1, SIGFPE);
    sigprocmask(SIG_BLOCK, &s1, &s2);

    int a, b;
    while (scanf("%d%d", &a, &b) == 2) {
        printf("%d\n", a / b);
    }
}
```

Если мы запустим эту программу и пошлем в нее сигнал `SIGFPE` из другого процесса,
```
kill -FPE $PID
```
то, ожидаемо, этот сигнал будет заблокирован и не будет доставлен в процесс.

Однако, если мы вызовем деление на 0, например, введя `2 0`,
то процесс будет завершен, как если бы сигнал `SIGFPE` не блокировался.
Это логично, так как если `SIGFPE` не будет обработан в процессе, то
процесс заведомо не может продолжить выполнение после инструкции деления.
Лучше процесс завершить, чем оставить его навсегда зависшим.

## Нелокальные переходы из обработчиков сигнала

Сигнал `SIGFPE`, возникающий при целочисленном делении на 0, вполне можно обрабатывать:

```
#include <stdio.h>
#include <signal.h>

void handler(int s)
{
    fprintf(stderr, "Division by 0\n");
}

int main(void)
{
    int a, b, c;
    signal(SIGFPE, handler);
    while (scanf("%d%d", &a, &b) == 2) {
        c = a / b;
        printf("%d\n", c);
    }
}
```

Однако когда при выполнении программы возникает исключение, при переходе на обработчик исключения
указатель текущей инструкции (EIP/RIP) сохраняет адрес ошибочной инструкции, а не
инструкции, следующей за ней. Поэтому, если в результате обработки сигнала `SIGFPE`
процесс не завершился, он вернется к выполнению той же самой ошибочной инструкции деления,
которая снова вызовет исключение деления на 0, и процесс зациклится между инструкцией
деления и обработчиком сигнала.

Чтобы такого не происходило, в случае возникновения исключения нужно как-то
пропустить ошибочную инструкцию и сразу перейти к выполнению какой-то другой
инструкции. Для этого можно использовать так называемые *нелокальные переходы*.

Функция `sigsetjmp` помечает место в программе, на которое можно вернуться
в случае выхода из обработчика сигнала. Функция сохраняет контекст процессора
в специальную структуру, которая имеет тип `sigjmp_buf`.
При первом вызове, когда сохраняется контекст процессора, эта функция возвращает 0.

Функция `siglongjmp` выполняет переход на сохраненную ранее точку восстановления
в программе. Точка восстановления должна быть сохранена с помощью функции `sigsetjmp`
где-то выше по стеку вызовов функции. При переходе уничтожаются данные в стеке
вплоть до стекового фрейма точки восстановления. С точки зрения выполнения программы
это выглядит так, как будто функция `sigsetjmp` вернула не нулевое, а какое-то другое значение.

```
#include <stdio.h>
#include <signal.h>
#include <setjmp.h>

sigjmp_buf jj;

void handler(int s)
{
    fprintf(stderr, "Division by 0\n");
    siglongjmp(jj, 42); // sigsetjmp вернет значение 42
}

int main(void)
{
    int a, b, c;
    signal(SIGFPE, handler);
    while (scanf("%d%d", &a, &b) == 2) {
        int x;
        if (!(x = sigsetjmp(jj, 1))) { // сохраняем точку восстановления
            // сюда попадаем после сохранения точки восстановления
            c = a / b;
            printf("%d\n", c);
        } else {
            // а сюда попадаем после вызова siglongjmp
            fprintf(stderr, "failed: %d\n", x); // печатаем значение, переданное из siglongjmp
        }
    }
}
```

Функции sigsetjmp/siglongjmp или setjmp/longjmp в каком-то смысле похожи на механизм исключений в Си++.
Однако в этом случае не освобождаются ресурсы, возможно выделенные в уничтоженных стековых фреймах.
Использоваться они должны с осторожностью и с осознанием возможных утечек ресурсов.
